C51 COMPILER V9.00   PID                                                                   04/22/2016 01:08:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PID
OBJECT MODULE PLACED IN ..\bin\PID.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE PID.c BROWSE INCDIR(..\HARDWARE;..\USER) DEBUG OBJECTEXTEND OBJECT(..\bin\P
                    -ID.obj)

line level    source

   1          #include "PID.h"
   2          #include "PWM.h"
   3          #include "Uart1.h"
   4          #include "string.h"
   5          
   6          unsigned int rin;
   7          unsigned int rout;
   8          unsigned int set_temper=3000;
   9          unsigned int temper;
  10          xdata struct PID spid; // PID Control Structure
  11          
  12          void KeyDown (){set_temper--;}
  13                   
  14          void KeyUp (){set_temper++;} 
  15          unsigned int getTemperSet(){return set_temper; }
  16          /************************************************
  17                        PID函数
  18          *************************************************/ 
  19          void PIDInit (struct PID *pp) 
  20          { 
  21   1        memset ( pp,0,sizeof(struct PID)); 
  22   1      } 
  23          /************************************************
  24                        增量控制PID函数体 
  25          51单片机最不擅长浮点数计算，转换成int型计算
  26          *************************************************/
  27          unsigned int PIDCalc( struct PID *pp, unsigned int NextPoint ) 
  28          { 
  29   1        unsigned int dError,Error,pError; 
  30   1        //增量法计算公式：
  31   1        //Pdt=Kp*[E(t)-E(t-1)]+Ki*E(t)+Kd*[E(t)-2*E(t-1)+E(t-2)]
  32   1        Error = set_temper - NextPoint;       // 偏差E(t) 
  33   1        pError=Error-pp->LastError;    //E(t)-E(t-1)
  34   1        dError=Error-2*pp->LastError+pp->PrevError; //E(t)-2*E(t-1)+E(t-2) 
  35   1        pp->PrevError = pp->LastError; 
  36   1        pp->LastError = Error; 
  37   1        return ( 
  38   1                  pp->Proportion * pError        //比例 
  39   1                  + pp->Integral *Error  //积分项 
  40   1                  + pp->Derivative * dError     // 微分项
  41   1                              );  
  42   1      } 
  43          
  44          /************************************************
  45                                          PID函数初始化
  46          *************************************************/
  47          void PIDBEGIN() 
  48          { 
  49   1        PIDInit(&spid); // Initialize Structure 
  50   1        spid.Proportion = 10; // Set PID Coefficients 
  51   1        spid.Integral = 5; 
  52   1        spid.Derivative =4; 
  53   1      }
  54          /*********************************************************** 
C51 COMPILER V9.00   PID                                                                   04/22/2016 01:08:09 PAGE 2   

  55                       PID温度控制做动函数
  56          ***********************************************************/ 
  57          
  58          void compare_temper(unsigned int v_input)               //PID温度控制输出函数
  59          { 
  60   1        unsigned char i; 
  61   1        temper =         v_input;
  62   1        if(set_temper>temper) 
  63   1         { 
  64   2          if(set_temper-temper>50)//如果控制目标温度温与实时温度差大于5度，（放大10倍）是50
  65   2           { 
  66   3             
  67   3                // PWM0_set(10); //PWM 输出高电平占空比最大。即全速加温
  68   3                 PWM1_set(10);
  69   3           }
  70   2              else 
  71   2          { 
  72   3           for(i=0;i<10;i++) //5度范围内PID增量控制，10次周期 即PID积分式中T=10
  73   3           { 
  74   4            rin=v_input;//PID输入实时温度采样值
  75   4            rout = PIDCalc ( &spid,rin ); // PID增量输出 
  76   4           }//PID增量输出范围（0-255）配合pwm取值范围 
  77   3           send_string_com("pid out:"); //串口输出监视数据 
  78   3               send_char_com(rin); //实时温度值
  79   3               send_char_com(rout);//PID增量输出值
  80   3               send_char_com(0x0d);//输出回车，换行间隔控制字符
  81   3               send_char_com(0x0a);//
  82   3               
  83   3               if(rout>=240)rout=240; //保障PWM输入值10-240 防止pwm出现失调。stc单片机特性。
  84   3               if(rout<=20)rout=20;
  85   3               
  86   3               //PWM0_set(255-rout); 
  87   3               PWM1_set(255-rout);
  88   3                
  89   3          } 
  90   2         } 
  91   1        else if(set_temper<=temper) //目标温度小于实时温度pwm输出低电平最高占空比，关闭加热。
  92   1         { 
  93   2           //PWM0_set(250); 
  94   2               PWM1_set(250);
  95   2         } 
  96   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    395    ----
   CONSTANT SIZE    =      9    ----
   XDATA SIZE       =     10    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
